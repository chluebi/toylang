use std::str::FromStr;
use std::rc::Rc;
use std::cell::RefCell;
use std::collections::HashMap;

use crate::ast;

grammar;

// The entry point of the grammar
pub Grammar: ast::Program = {
    <fs:Functions> => {
        ast::Program {
            functions: fs
        }
    }
};

Functions: HashMap<String, ast::Function> = {
    <fs:Functions> <f:Function> => {
        let mut funcs = fs;
        funcs.insert(f.name.clone(), f);
        funcs
    },
    <f:Function> => {
        let mut funcs = HashMap::new();
        funcs.insert(f.name.clone(), f);
        funcs
    }
};

Function: ast::Function = {
    <name:Ident> "(" <args:Arguments> ")" "{" <body:Body> "}" => {
        ast::Function {
            name: name,
            arguments: args,
            body: body,
        }
    }
};


Arguments: Vec<String> = {
    <arg:Argument> "," <args:Arguments> => {
        let mut args = args;
        args.insert(0, arg);
        args
    },
    <arg:Argument> => vec![arg],
    => vec![]
};


Argument: String = {
    <i:Ident> => i,
};


Body: ast::Body = {
    <stmts:Statements> => {
        ast::Body {
            statements: stmts
        }
    },
};


Statements: Vec<ast::Statement> = {
    <stmt:Statement> ";" <stmts:Statements> => {
        let mut stmts = stmts;
        stmts.insert(0, stmt);
        stmts
    },
    <c_stmts:ControlFlow> <stmts:Statements> => {
        let mut c_stmts = c_stmts;
        c_stmts.extend(stmts);
        c_stmts
    },
    <stmt:Statement> => vec![stmt],
    => vec![]
};


ControlFlow: Vec<ast::Statement> = {
    "if" <c:Expression> "{" <if_body:Body> "}" "else" "{" <else_body:Body> "}"  => {
        vec![ast::Statement::IfElse {
            condition: c,
            if_body: if_body,
            else_body: else_body
        }]
    },
    "while" <c:Expression> "{" <b:Body> "}" => {
        vec![ast::Statement::While {
            condition: c,
            body: b
        }]
    },
    "for" "(" <start:Statement> ";" <c:Expression> ";" <step:Statements> ")" "{" <body:Statements> "}" => {
        let mut stmts = vec![start];
        let mut body = body;
        body.extend(step);
        stmts.push(
            ast::Statement::While {
                condition: c,
                body: ast::Body {
                    statements: body
                }
            }
        );
        stmts
    }
}


Statement: ast::Statement = {
    <t:LHSExpression> "=" <e:Expression> => {
        ast::Statement::Assignment {
            target: t,
            expression: e
        }
    },
    <t:LHSExpression> "[" "]" "=" <value:Expression> => {
        ast::Statement::ListAppend {
            target: t,
            value: value
        }
    },
    "return" <e:Expression> => {
        ast::Statement::Return {
            expression: e
        }
    },

    <t:LHSExpression> "+=" <e:Expression> => {
        ast::Statement::Assignment {
            target: t.clone(),
            expression: ast::Expression::BinaryOperation {
                operator: ast::BinOperator::Add,
                left: Box::new(t),
                right: Box::new(e)
            }
        }
    },
    <t:LHSExpression> "-=" <e:Expression> => {
        ast::Statement::Assignment {
            target: t.clone(),
            expression: ast::Expression::BinaryOperation {
                operator: ast::BinOperator::Sub,
                left: Box::new(t),
                right: Box::new(e)
            }
        }
    },
    <t:LHSExpression> "*=" <e:Expression> => {
        ast::Statement::Assignment {
            target: t.clone(),
            expression: ast::Expression::BinaryOperation {
                operator: ast::BinOperator::Mul,
                left: Box::new(t),
                right: Box::new(e)
            }
        }
    },
    <t:LHSExpression> "/=" <e:Expression> => {
        ast::Statement::Assignment {
            target: t.clone(),
            expression: ast::Expression::BinaryOperation {
                operator: ast::BinOperator::Div,
                left: Box::new(t),
                right: Box::new(e)
            }
        }
    },

    <t:LHSExpression> "++" => {
        ast::Statement::Assignment {
            target: t.clone(),
            expression: ast::Expression::BinaryOperation {
                operator: ast::BinOperator::Add,
                left: Box::new(t),
                right: Box::new(ast::Expression::IntLiteral(1))
            }
        }
    },
    <t:LHSExpression> "--" => {
        ast::Statement::Assignment {
            target: t.clone(),
            expression: ast::Expression::BinaryOperation {
                operator: ast::BinOperator::Sub,
                left: Box::new(t),
                right: Box::new(ast::Expression::IntLiteral(1))
            }
        }
    }
};

LHSExpression: ast::Expression = {
    <id: Ident> => ast::Expression::Variable(id),
    <indexed:LHSExpression> "[" <indexer: IndexExpression> "]" => ast::Expression::Indexing {
        indexed: Box::new(indexed), indexer: Box::new(indexer)
    }
};


Expression: ast::Expression = {
    #[precedence(level="0")]
    Term,
    #[precedence(level="1")] #[assoc(side="left")]
    "(" <e:Expression> "," <elts: CommaSeperatedExpressions> ")" => {
        let mut elts = elts;
        elts.insert(0, e);
        return ast::Expression::Tuple {elements: elts};
    },
    "[" <elts: CommaSeperatedExpressions> "]" => ast::Expression::ListReference {elements_ref: Rc::new(RefCell::new(elts))},
    "{" <elts: CommaSeperatedMappings> "}" => ast::Expression::DictionaryInitialisation {elements: elts},
    <indexed: Expression> "[" <indexer: IndexExpression> "]" => ast::Expression::Indexing {
        indexed: Box::new(indexed), indexer: Box::new(indexer)
    },
    <id:Ident> "(" <args:CommaSeperatedExpressions> ")" => {
        ast::Expression::FunctionCall {
            function_name: id,
            arguments: args
        }
    },
    #[precedence(level="2")] #[assoc(side="left")]
    "-" <e:Term> => {
        ast::Expression::UnaryOperation {
            operator: ast::UnOperator::Neg,
            expression: Box::new(e),
        }
    },
    "!" <e:Term> => {
        ast::Expression::UnaryOperation {
            operator: ast::UnOperator::Not,
            expression: Box::new(e),
        }
    },
    "?" <e:Term> => {
        ast::Expression::UnaryOperation {
            operator: ast::UnOperator::Length,
            expression: Box::new(e),
        }
    },
    #[precedence(level="3")] #[assoc(side="left")]
    <l:Expression> "*" <r:Expression> => {
        ast::Expression::BinaryOperation {
            operator: ast::BinOperator::Mul,
            left: Box::new(l),
            right: Box::new(r)
        }
    },
    <l:Expression> "/" <r:Expression> => {
        ast::Expression::BinaryOperation {
            operator: ast::BinOperator::Div,
            left: Box::new(l),
            right: Box::new(r)
        }
    },
    <l:Expression> "%" <r:Expression> => {
        ast::Expression::BinaryOperation {
            operator: ast::BinOperator::Mod,
            left: Box::new(l),
            right: Box::new(r)
        }
    },
    #[precedence(level="4")] #[assoc(side="left")]
    <l:Expression> "+" <r:Expression> => {
        ast::Expression::BinaryOperation {
            operator: ast::BinOperator::Add,
            left: Box::new(l),
            right: Box::new(r)
        }
    },
    <l:Expression> "-" <r:Expression> => {
        ast::Expression::BinaryOperation {
            operator: ast::BinOperator::Sub,
            left: Box::new(l),
            right: Box::new(r)
        }
    },
    #[precedence(level="5")] #[assoc(side="left")]
    <l:Expression> "++" <r:Expression> => {
        ast::Expression::BinaryOperation {
            operator: ast::BinOperator::ListConcat,
            left: Box::new(l),
            right: Box::new(r)
        }
    },
    #[precedence(level="6")] #[assoc(side="left")]
    <l:Expression> "??" <r:Type> => {
        ast::Expression::Typecheck {
            expression: Box::new(l),
            expected_type: r
        }
    },
    #[precedence(level="7")] #[assoc(side="left")]
    <l:Expression> "&&" <r:Expression> => {
        ast::Expression::BinaryOperation {
            operator: ast::BinOperator::And,
            left: Box::new(l),
            right: Box::new(r)
        }
    },
    #[precedence(level="8")] #[assoc(side="left")]
    <l:Expression> "||" <r:Expression> => {
        ast::Expression::BinaryOperation {
            operator: ast::BinOperator::Or,
            left: Box::new(l),
            right: Box::new(r)
        }
    },
    #[precedence(level="9")] #[assoc(side="left")]
    <l:Expression> "==" <r:Expression> => {
        ast::Expression::BinaryOperation {
            operator: ast::BinOperator::Eq,
            left: Box::new(l),
            right: Box::new(r)
        }
    },
    <l:Expression> "!=" <r:Expression> => {
        ast::Expression::BinaryOperation {
            operator: ast::BinOperator::Neq,
            left: Box::new(l),
            right: Box::new(r)
        }
    },
    <l:Expression> "<" <r:Expression> => {
        ast::Expression::BinaryOperation {
            operator: ast::BinOperator::Lt,
            left: Box::new(l),
            right: Box::new(r)
        }
    },
    <l:Expression> ">" <r:Expression> => {
        ast::Expression::BinaryOperation {
            operator: ast::BinOperator::Gt,
            left: Box::new(l),
            right: Box::new(r)
        }
    },
    <l:Expression> "<=" <r:Expression> => {
        ast::Expression::BinaryOperation {
            operator: ast::BinOperator::Leq,
            left: Box::new(l),
            right: Box::new(r)
        }
    },
    <l:Expression> ">=" <r:Expression> => {
        ast::Expression::BinaryOperation {
            operator: ast::BinOperator::Geq,
            left: Box::new(l),
            right: Box::new(r)
        }
    },
}

IndexExpression: ast::Expression = {
    Expression
}


Term: ast::Expression = {
    "true" => ast::Expression::BoolLiteral(true),
    "false" => ast::Expression::BoolLiteral(false),
    <n:Num> => ast::Expression::IntLiteral(n),
    <id: Ident> => ast::Expression::Variable(id),
    "(" <e: Expression> ")" => e
}


CommaSeperatedExpressions: Vec<ast::Expression> = {
    <exp:Expression> "," <exps:CommaSeperatedExpressions> => {
        let mut exps = exps;
        exps.insert(0, exp);
        exps
    },
    <exp:Expression> => vec![exp],
    => vec![]
}

CommaSeperatedMappings: Vec<(ast::Expression, ast::Expression)> = {
    <m:Mapping> "," <mappings:CommaSeperatedMappings> => {
        let mut mappings = mappings;
        mappings.insert(0, m);
        mappings
    },
    <m:Mapping> => vec![m],
    => vec![]
}

Mapping: (ast::Expression, ast::Expression) = {
    <key:Expression> ":" <value:Expression> => (key, value)
}

Type: ast::Type = {
    "int" => ast::Type::Int,
    "bool" => ast::Type::Bool,
    "tuple" => ast::Type::Tuple,
    "list" => ast::Type::List
}


Num: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();


Ident: String = {
    <id:r"[a-zA-Z_][a-zA-Z0-9_]*"> => id.to_string(),
};
